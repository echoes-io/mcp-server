import z from 'zod';

import { DEFAULT_DB_PATH } from '../constants.js';
import { Database } from '../database/index.js';
import type { ToolConfig } from '../types.js';

export const reviewGenerateConfig: ToolConfig = {
  name: 'review-generate',
  description: 'Generate review file for pending entity/relation extractions.',
  arguments: {
    arc: 'Arc name to generate review for.',
    output: 'Output file path (default: .echoes-review.yaml).',
    filter: 'Filter by review status: pending or all (default: pending).',
    dbPath: `Database path (default: ${DEFAULT_DB_PATH}).`,
  },
};

export const reviewGenerateSchema = z.object({
  arc: z.string().min(1).describe(reviewGenerateConfig.arguments.arc),
  output: z.string().optional().describe(reviewGenerateConfig.arguments.output),
  filter: z.enum(['pending', 'all']).optional().describe(reviewGenerateConfig.arguments.filter),
  dbPath: z.string().default(DEFAULT_DB_PATH).describe(reviewGenerateConfig.arguments.dbPath),
});

export type ReviewGenerateInput = z.infer<typeof reviewGenerateSchema>;

interface ReviewEntity {
  id: string;
  name: string;
  type: string;
  description: string;
  aliases: string[];
  status: string;
}

interface ReviewRelation {
  id: string;
  source: string;
  target: string;
  type: string;
  description: string;
  weight: number;
  chapters: string[];
  status: string;
}

interface ReviewFile {
  metadata: {
    arc: string;
    generated_at: string;
    generated_by: string;
  };
  entities: ReviewEntity[];
  relations: ReviewRelation[];
  additions: {
    entities: Array<{
      name: string;
      type: string;
      description: string;
      aliases: string[];
    }>;
    relations: Array<{
      source: string;
      target: string;
      type: string;
      description: string;
      chapters: string[];
    }>;
  };
}

function toYaml(obj: ReviewFile): string {
  const lines: string[] = [];

  // Metadata
  lines.push('# Generated by echoes-mcp-server');
  lines.push(`# Arc: ${obj.metadata.arc}`);
  lines.push(`# Generated at: ${obj.metadata.generated_at}`);
  lines.push('');

  // Entities
  lines.push('entities:');
  if (obj.entities.length === 0) {
    lines.push('  []');
  } else {
    for (const entity of obj.entities) {
      lines.push(`  - id: "${entity.id}"`);
      lines.push(`    name: "${entity.name}"`);
      lines.push(`    type: "${entity.type}"`);
      lines.push(`    description: "${entity.description}"`);
      const aliases = Array.isArray(entity.aliases) ? entity.aliases : [];
      lines.push(`    aliases: [${aliases.map((a) => `"${a}"`).join(', ')}]`);
      lines.push(`    status: ${entity.status}`);
      lines.push('');
    }
  }

  // Relations
  lines.push('relations:');
  if (obj.relations.length === 0) {
    lines.push('  []');
  } else {
    for (const relation of obj.relations) {
      lines.push(`  - id: "${relation.id}"`);
      lines.push(`    source: "${relation.source}"`);
      lines.push(`    target: "${relation.target}"`);
      lines.push(`    type: "${relation.type}"`);
      lines.push(`    description: "${relation.description}"`);
      lines.push(`    weight: ${relation.weight}`);
      const chapters = Array.isArray(relation.chapters) ? relation.chapters : [];
      lines.push(`    chapters: [${chapters.map((c) => `"${c}"`).join(', ')}]`);
      lines.push(`    status: ${relation.status}`);
      lines.push('');
    }
  }

  // Additions template
  lines.push('# Add new entities/relations below:');
  lines.push('additions:');
  lines.push('  entities: []');
  lines.push('  relations: []');

  return lines.join('\n');
}

export async function reviewGenerate(
  input: ReviewGenerateInput,
): Promise<{ file: string; content: string; stats: { entities: number; relations: number } }> {
  const { arc, dbPath } = reviewGenerateSchema.parse(input);
  const output = input.output || '.echoes-review.yaml';
  const filter = input.filter || 'pending';

  const db = new Database(dbPath);
  await db.connect();

  // Get entities and relations
  const entities = await db.getEntities(arc);
  const relations = await db.getRelations(arc);

  db.close();

  // Filter by review status
  const filteredEntities = entities.filter(
    (e) => filter === 'all' || (e as any).review_status === 'pending' || !(e as any).review_status,
  );

  const filteredRelations = relations.filter(
    (r) => filter === 'all' || (r as any).review_status === 'pending' || !(r as any).review_status,
  );

  // Build review file
  const reviewFile: ReviewFile = {
    metadata: {
      arc,
      generated_at: new Date().toISOString(),
      generated_by: 'echoes-mcp-server',
    },
    entities: filteredEntities.map((e) => ({
      id: e.id,
      name: e.name,
      type: e.type,
      description: e.description,
      aliases: e.aliases,
      status: (e as any).review_status || 'pending',
    })),
    relations: filteredRelations.map((r) => ({
      id: r.id,
      source: r.source_entity.split(':').pop() || '',
      target: r.target_entity.split(':').pop() || '',
      type: r.type,
      description: r.description,
      weight: r.weight,
      chapters: r.chapters,
      status: (r as any).review_status || 'pending',
    })),
    additions: {
      entities: [],
      relations: [],
    },
  };

  const content = toYaml(reviewFile);

  return {
    file: output,
    content,
    stats: {
      entities: reviewFile.entities.length,
      relations: reviewFile.relations.length,
    },
  };
}
